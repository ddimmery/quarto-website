name: Publish Post to Listmonk

on:
  workflow_dispatch:
    inputs:
      post_slug:
        description: 'Post slug (e.g., "back-to-basics" for posts/back-to-basics/)'
        required: true
        type: string
      send_at:
        description: 'Schedule send time (e.g., "2025-10-25 14:00", "tomorrow 2pm", "Oct 25 2pm"). Leave empty to send immediately.'
        required: false
        type: string
      timezone:
        description: 'Timezone for send_at (e.g., "America/New_York", "UTC", "Europe/London")'
        required: false
        type: string
        default: 'Europe/Berlin'
      list_ids:
        description: 'Comma-separated Listmonk list IDs to send to (uses default list if not provided)'
        required: false
        type: string
        default: '3'
      campaign_name_suffix:
        description: 'Optional suffix for campaign name (default: auto-generated from date)'
        required: false
        type: string
      from_email:
        description: 'From email address (optional, uses Listmonk default if not set)'
        required: false
        type: string
      send_test:
        description: 'Send test email first?'
        required: false
        type: boolean
        default: false
      test_emails:
        description: 'Comma-separated test email addresses (required if send_test is true)'
        required: false
        type: string

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Poetry
        run: pipx install poetry

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
          cache: 'poetry'

      - name: Install dependencies
        run: |
          poetry env use 3.12
          poetry install --no-root
          poetry run python -m ipykernel install --user --name quarto-env --display-name "Quarto Environment"

      - name: Set up Quarto
        uses: quarto-dev/quarto-actions/setup@v2

      - name: Parse and convert send time
        id: parse_time
        if: ${{ github.event.inputs.send_at != '' }}
        run: |
          SEND_AT_ISO=$(poetry run python scripts/listmonk/parse_send_time.py \
            "${{ github.event.inputs.send_at }}" \
            "${{ github.event.inputs.timezone }}")

          echo "send_at_iso=$SEND_AT_ISO" >> $GITHUB_OUTPUT
          echo "Parsed send time: $SEND_AT_ISO"

      - name: Verify post exists and extract metadata
        id: extract_metadata
        run: |
          POST_PATH="posts/${{ github.event.inputs.post_slug }}/index.qmd"

          if [ ! -f "$POST_PATH" ]; then
            echo "Error: Post not found at $POST_PATH"
            exit 1
          fi

          # Extract metadata from YAML frontmatter
          METADATA=$(poetry run python scripts/listmonk/extract_post_metadata.py "$POST_PATH")

          TITLE=$(echo "$METADATA" | jq -r '.title')
          DESCRIPTION=$(echo "$METADATA" | jq -r '.description')

          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "post_path=$POST_PATH" >> $GITHUB_OUTPUT
          echo "post_url=https://ddimmery.com/posts/${{ github.event.inputs.post_slug }}/" >> $GITHUB_OUTPUT

          # Generate campaign name
          if [ -n "${{ github.event.inputs.campaign_name_suffix }}" ]; then
            CAMPAIGN_NAME="$TITLE - ${{ github.event.inputs.campaign_name_suffix }}"
          else
            CAMPAIGN_NAME="$TITLE - $(date +%Y-%m-%d)"
          fi
          echo "campaign_name=$CAMPAIGN_NAME" >> $GITHUB_OUTPUT

      - name: Render post to HTML
        run: |
          export QUARTO_PYTHON=$(poetry run which python)
          poetry run quarto render "${{ steps.extract_metadata.outputs.post_path }}" --to html

      - name: Prepare email HTML content
        id: extract_html
        run: |
          HTML_PATH="_site/posts/${{ github.event.inputs.post_slug }}/index.html"

          if [ ! -f "$HTML_PATH" ]; then
            echo "Error: Rendered HTML not found at $HTML_PATH"
            exit 1
          fi

          # Extract content and add header/reading note
          poetry run python scripts/listmonk/prepare_email_html.py \
            "$HTML_PATH" \
            "${{ steps.extract_metadata.outputs.title }}" \
            "${{ steps.extract_metadata.outputs.post_url }}" \
            > /tmp/email_body.html

          echo "body_file=/tmp/email_body.html" >> $GITHUB_OUTPUT

      - name: Create Listmonk campaign
        id: create_campaign
        env:
          LISTMONK_URL: ${{ secrets.LISTMONK_URL }}
          LISTMONK_USER: ${{ secrets.LISTMONK_API_USER }}
          LISTMONK_PASSWORD: ${{ secrets.LISTMONK_API_PASSWORD }}
          LISTMONK_DEFAULT_LIST_ID: ${{ secrets.LISTMONK_DEFAULT_LIST_ID }}
        run: |
          # Use provided list IDs or fall back to default
          LIST_IDS_INPUT="${{ github.event.inputs.list_ids }}"
          if [ -z "$LIST_IDS_INPUT" ]; then
            LIST_IDS_INPUT="$LISTMONK_DEFAULT_LIST_ID"
          fi

          # Convert comma-separated list IDs to JSON array
          LIST_IDS=$(echo "$LIST_IDS_INPUT" | poetry run python scripts/listmonk/convert_to_json_array.py)

          # Build JSON payload
          PAYLOAD=$(poetry run python scripts/listmonk/build_campaign_payload.py \
            "${{ steps.extract_metadata.outputs.campaign_name }}" \
            "${{ steps.extract_metadata.outputs.title }}" \
            "$LIST_IDS" \
            "/tmp/email_body.html" \
            "${{ github.event.inputs.from_email }}" \
            "${{ steps.parse_time.outputs.send_at_iso }}" \
            "${{ steps.extract_metadata.outputs.description }}")

          # Create campaign via API
          RESPONSE=$(curl -s -u "$LISTMONK_USER:$LISTMONK_PASSWORD" \
            -X POST "$LISTMONK_URL/api/campaigns" \
            -H 'Content-Type: application/json' \
            --data "$PAYLOAD")

          echo "API Response: $RESPONSE"

          # Extract campaign ID
          CAMPAIGN_ID=$(echo "$RESPONSE" | poetry run python scripts/listmonk/parse_api_response.py)

          echo "campaign_id=$CAMPAIGN_ID" >> $GITHUB_OUTPUT
          echo "Created campaign with ID: $CAMPAIGN_ID"

      - name: Send test email (optional)
        if: ${{ github.event.inputs.send_test == 'true' }}
        env:
          LISTMONK_URL: ${{ secrets.LISTMONK_URL }}
          LISTMONK_USER: ${{ secrets.LISTMONK_API_USER }}
          LISTMONK_PASSWORD: ${{ secrets.LISTMONK_API_PASSWORD }}
        run: |
          if [ -z "${{ github.event.inputs.test_emails }}" ]; then
            echo "Error: test_emails must be provided when send_test is true"
            exit 1
          fi

          # Convert comma-separated emails to JSON array
          TEST_SUBSCRIBERS=$(echo "${{ github.event.inputs.test_emails }}" | poetry run python scripts/listmonk/convert_to_json_array.py)

          curl -u "$LISTMONK_USER:$LISTMONK_PASSWORD" \
            -X POST "$LISTMONK_URL/api/campaigns/${{ steps.create_campaign.outputs.campaign_id }}/test" \
            -H 'Content-Type: application/json' \
            --data "{\"subscribers\": $TEST_SUBSCRIBERS}"

          echo "Test email sent to: ${{ github.event.inputs.test_emails }}"

      - name: Schedule or start campaign
        env:
          LISTMONK_URL: ${{ secrets.LISTMONK_URL }}
          LISTMONK_USER: ${{ secrets.LISTMONK_API_USER }}
          LISTMONK_PASSWORD: ${{ secrets.LISTMONK_API_PASSWORD }}
        run: |
          # If send_at was provided, the campaign is already scheduled
          # We just need to change status to 'scheduled'
          # Otherwise, start it immediately with 'running'

          if [ -n "${{ steps.parse_time.outputs.send_at_iso }}" ]; then
            STATUS="scheduled"
            echo "Scheduling campaign for ${{ steps.parse_time.outputs.send_at_iso }}"
          else
            STATUS="running"
            echo "Starting campaign immediately"
          fi

          curl -u "$LISTMONK_USER:$LISTMONK_PASSWORD" \
            -X PUT "$LISTMONK_URL/api/campaigns/${{ steps.create_campaign.outputs.campaign_id }}/status" \
            -H 'Content-Type: application/json' \
            --data "{\"status\": \"$STATUS\"}"

          echo "Campaign status set to: $STATUS"

      - name: Output summary
        run: |
          echo "## Campaign Published Successfully! ðŸš€" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Post:** ${{ steps.extract_metadata.outputs.title }}" >> $GITHUB_STEP_SUMMARY
          echo "**Campaign ID:** ${{ steps.create_campaign.outputs.campaign_id }}" >> $GITHUB_STEP_SUMMARY

          # Show which lists were used
          LIST_IDS_INPUT="${{ github.event.inputs.list_ids }}"
          if [ -z "$LIST_IDS_INPUT" ]; then
            echo "**Lists:** Default list (${{ secrets.LISTMONK_DEFAULT_LIST_ID }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Lists:** $LIST_IDS_INPUT" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "${{ steps.parse_time.outputs.send_at_iso }}" ]; then
            echo "**Scheduled for (UTC):** ${{ steps.parse_time.outputs.send_at_iso }}" >> $GITHUB_STEP_SUMMARY
            echo "**Original input:** ${{ github.event.inputs.send_at }} (${{ github.event.inputs.timezone }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** Sending immediately" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ github.event.inputs.send_test }}" = "true" ]; then
            echo "**Test sent to:** ${{ github.event.inputs.test_emails }}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "View campaign in Listmonk: ${{ secrets.LISTMONK_URL }}/campaigns/${{ steps.create_campaign.outputs.campaign_id }}" >> $GITHUB_STEP_SUMMARY
